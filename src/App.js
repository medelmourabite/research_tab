const DragIcon = (props) => <img {...props} src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAEXklEQVR4Xu2bx24VMRSGv7Cii/oE1A11QVnSJZpASDwGEiABj0DnQUCUQEQHsQHBDggs6FvqBggriv7IEyaTO+NybWeulNlF1+Wcz8f2KU4f4/MtBs4BG4A+4AFwAHiVWxxNnvtbDdwG5lQm/gpsAp7mFCg3ACl/B5hdo6QgbASe5YKQE8Aq4G6D8oXOWSHkAiDltfJVs69b6C9mOyS3hBwAfJUvoGSBkBrASmP2ritftQhB0JnwPNWZkBJAt8qXLSEZhFQApLz2/NxIK/fZnAnRLSEFADk5DyMqXzAUhPXA20hQh4dJAeAqsDOmkKWxrgB7Yo6dAsAQMCWmkKWxfgLTY46dAsAPYFpMIUtjaewZMcdOAUBmurtGSO3j+RYFmtpcBPa1HcAS4FEHl/ejOckHLQosN75DFZR8gnW9cAhKv4XAcWArMAm4CRwGPgB/LQBklQuA08AW4A9wHTgGvI+5+qluAZuMLgBsY0T7PcUZYBNuAoDDFrBBjPb7hAU4opR7e8ac4jqU5OcfCczhpdgCS4GTRj4tqlJuh1xuDBcLqAtsvgFrXCapQI4NQIvzGJhVmccpgLIBsEV154H9jlZUNIsN4FJDfGCF0ATAJZ7/DswcZwA217sxqVIHwEV56R0SnMS2AJfgqxZCJwA+ObwQ3zw2gH5gl4MVdswxVgH4KC/fXr653FufLzYAuc2KPWxBlmQcA6EMoK5i00k5HS4qa73w0dy0jQ1AwyqAuueYhRoFoQBgq9gE6NnqLiPFFwHQPSoTCk1dt1rTBuEEYa0ADADbe1WLLuXuFwCXa6TLeVrbfUgAfgGTWytiWsGGAdwAtqWdp7WjDxSHYIpCRmu1NoLpKl9XXIMrTCIyVimrF5RXvXGw7Aj5QLBGWQ0EUjhCvrIPKy8Zq66wj0cVWquLDcCnFjnGg+0UDBV5+XkOdnwZ2OvQrtwkNoBrwA4HGT6Ztwaj3Pe6cNgVQhvCYZdrvKPynbZAGaQLhF5IiNQqbwOg35eZKKtuO7QhJXahoV4o5RW1vqzbIracYAFBz9uq8baCCSVF3znsv5RngPIBTzoEc8pX6LSvVd7FAgrBNYnS4ptNbU9pZ6XF33gqr+axD0GNqVrkKSOf/r5VqkU2iuhiAQE6NnZJASBYxgkAwejCO05YgIVdVqtMNdki4ETpgYRqiQdNGc3FAuTenjW1vt/mgcXRwEM3+yGoQqXC6+qTePnhukVs/w9QFGWqkalqkUrDvw7ffWN7prCApkKFfAdbyN3UpifeCSo+mBpzlUpj9cQzuZRJ1p4A0PROsFvDCKlFZj8EfWp1PkBCa5HZAbhEkT6Kq601qvMdsGif4hYoxraF0q4yJ1PeJxp0FbbaziWp0jR2YzIjVKhyv5QWUMwTCiG58jksoAzBtX6vPt28P/AyjBwW4Ashm/I5LaCAYCtgSPmRooXXUgY2zmkBNgjZlR8PCyggyFlSuKvoUN998+/zvgnWwHX/3+0fUHrv1bTPYJQAAAAASUVORK5CYII=" />
const DeleteIcon = (props) => <img {...props} src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pjxzdmcgdmlld0JveD0iMCAwIDk2IDk2IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjx0aXRsZS8+PGc+PHBhdGggZD0iTTQ4LDBBNDgsNDgsMCwxLDAsOTYsNDgsNDguMDUxMiw0OC4wNTEyLDAsMCwwLDQ4LDBabTAsODRBMzYsMzYsMCwxLDEsODQsNDgsMzYuMDM5MywzNi4wMzkzLDAsMCwxLDQ4LDg0WiIvPjxwYXRoIGQ9Ik02NC4yNDIyLDMxLjc1NzhhNS45OTc5LDUuOTk3OSwwLDAsMC04LjQ4NDQsMEw0OCwzOS41MTU2bC03Ljc1NzgtNy43NTc4YTUuOTk5NCw1Ljk5OTQsMCwwLDAtOC40ODQ0LDguNDg0NEwzOS41MTU2LDQ4bC03Ljc1NzgsNy43NTc4YTUuOTk5NCw1Ljk5OTQsMCwxLDAsOC40ODQ0LDguNDg0NEw0OCw1Ni40ODQ0bDcuNzU3OCw3Ljc1NzhhNS45OTk0LDUuOTk5NCwwLDAsMCw4LjQ4NDQtOC40ODQ0TDU2LjQ4NDQsNDhsNy43NTc4LTcuNzU3OEE1Ljk5NzksNS45OTc5LDAsMCwwLDY0LjI0MjIsMzEuNzU3OFoiLz48L2c+PC9zdmc+" />
const TransIcon = (props) => <img {...props} src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/PjxzdmcgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDQ4IDQ4IiB3aWR0aD0iNDgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTAgMGg0OHY0OEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0yNS43NCAzMC4xNWwtNS4wOC01LjAyLjA2LS4wNmMzLjQ4LTMuODggNS45Ni04LjM0IDcuNDItMTMuMDZIMzRWOEgyMFY0aC00djRIMnYzLjk4aDIyLjM0QzIyLjk5IDE1Ljg0IDIwLjg4IDE5LjUgMTggMjIuN2MtMS44Ni0yLjA3LTMuNC00LjMyLTQuNjItNi43aC00YzEuNDYgMy4yNiAzLjQ2IDYuMzQgNS45NiA5LjEyTDUuMTcgMzUuMTcgOCAzOGwxMC0xMCA2LjIyIDYuMjIgMS41Mi00LjA3ek0zNyAyMGgtNGwtOSAyNGg0bDIuMjUtNmg5LjVMNDIgNDRoNGwtOS0yNHptLTUuMjUgMTRMMzUgMjUuMzMgMzguMjUgMzRoLTYuNXoiLz48L3N2Zz4=" />

const DEFAULT_SETTINGS = {
    dir: "ltr",
    lng: "ar"
};

class ContentEditable extends React.Component {
    constructor() {
        super();
        this.emitChange = this.emitChange.bind(this);
    }

    render() {
        var { tagName, html, onChange, ...props } = this.props;

        return React.createElement(
            tagName || 'div',
            {
                ...props,
                ref: (e) => this.htmlEl = e,
                onInput: this.emitChange,
                onBlur: this.props.onBlur || this.emitChange,
                contentEditable: !this.props.disabled,
                dangerouslySetInnerHTML: { __html: html }
            },
            this.props.children);
    }

    shouldComponentUpdate(nextProps) {
        // We need not rerender if the change of props simply reflects the user's
        // edits. Rerendering in this case would make the cursor/caret jump.
        return (
            // Rerender if there is no element yet... (somehow?)
            !this.htmlEl
            // ...or if html really changed... (programmatically, not by user edit)
            || (nextProps.html !== this.htmlEl.innerHTML
                && nextProps.html !== this.props.html)
            // ...or if editing is enabled or disabled.
            || this.props.disabled !== nextProps.disabled
        );
    }

    componentDidUpdate() {
        if (this.htmlEl && this.props.html !== this.htmlEl.innerHTML) {
            // Perhaps React (whose VDOM gets outdated because we often prevent
            // rerendering) did not update the DOM. So we update it manually now.
            this.htmlEl.innerHTML = this.props.html;
        }
    }

    emitChange(evt) {
        if (!this.htmlEl) return;
        var html = this.htmlEl.innerHTML;
        if (this.props.onChange && html !== this.lastHtml) {
            evt.target = { value: html };
            this.props.onChange(evt);
        }
        this.lastHtml = html;
    }
}


const Header = () => {
    return <div>HEADER</div>
}

const Footer = () => {
    return <div>Footer</div>
}

class NewNote extends React.Component {
    constructor(props) {
        super(props);
        this.state = { text: "" };
    }

    save = () => {
        const { text } = this.state;
        this.props.addNote(text);
    }

    render() {
        return <div className="note-new">
            <textarea onChange={(e => this.setState({ text: e.target.value }))} />
            <button onClick={this.save}>save</button>
        </div>
    }
}

class Menu extends React.Component {
    constructor(props) {
        super(props);
        this.state = { ...DEFAULT_SETTINGS };
    }

    componentDidMount() {
        console.error("MOUT");
        LocalStorage.get("settings", (settings) => {
            if (settings) {
                this.setState(settings);
                const { dir } = settings;
                document.body.setAttribute("dir", dir)
            }
        }, true);
    }

    onDirChange = (dir) => {
        const s = { ...this.state, dir };
        LocalStorage.set("settings", s, true);
        this.setState(s);
        document.body.setAttribute("dir", dir)
    }

    render() {
        const { dir } = this.state;

        return <div className="menu">
            <div className="menu-option">
                <span>Direction</span>
                <br />
                <span>
                    RTL: <input type="radio" checked={dir === "rtl"} value="rtl" onChange={(ev) => this.onDirChange(ev.target.value)} />
                </span>
                <span>
                    LTR: <input type="radio" checked={dir !== "rtl"} value="ltr" onChange={(ev) => this.onDirChange(ev.target.value)} />
                </span>
            </div>
        </div>
    }

}

class Body extends React.Component {
    constructor(props) {
        super(props);
        this.state = { notes: [] };
    }

    componentDidMount() {
        console.error("MOUT");
        LocalStorage.get("notes", (notes) => {
            this.setState({ notes: notes || [] });
        }, true);

        const list = document.querySelector("ul.notes");

        new Sortable(list, {
            handle: '.handle',
            animation: 150,
            ghostClass: 'blue-background-class',
            onEnd: (evt) => {
                const notes = [...this.state.notes];
                var tmp = notes[evt.oldIndex];
                notes[evt.oldIndex] = notes[evt.newIndex];
                notes[evt.newIndex] = tmp;
                //this.setState({notes});
                LocalStorage.set("notes", notes, true);
            }
        });
    }

    addNote = (text) => {
        const { notes } = this.state;
        const n = [...notes, { _id: notes.length, text }];
        this.setState({ notes: n });
        LocalStorage.set("notes", n, true);
    }

    deleteNote = (_id) => {
        const { notes } = this.state;
        const n = notes.filter((note) => note._id !== _id);
        this.setState({ notes: n });
        LocalStorage.set("notes", n, true);
    }

    editNote = (_id, text) => {
        const { notes } = this.state;
        const n = notes.reduce((acc, note) => {
            if (note._id === _id) {
                note = { ...note, text };
            }
            acc.push(note);
            return acc;
        }, []);
        this.setState({ notes: n });
        LocalStorage.set("notes", n, true);
    }

    translateNote = ({ _id, text }) => {
        TranslationApi.trans(text, res => {
            this.editNote(_id, res.translatedText)
        });
    }

    copyNotes = () => {
        const { notes } = this.state;
        Utils.copy(notes.map(({text}) => text).join("\n"));
    }

    render() {
        const { notes } = this.state;

        return <div className="body">
            {/*<NewNote addNote={this.addNote} />*/}
            <ul className="notes">
                {notes.map((note) => <li key={note._id} id={"note_" + note._id}>
                    <DragIcon className="handle" />
                    <ContentEditable onChange={(ev) => this.editNote(note._id, ev.target.value)} html={note.text} />
                    <span className="options">
                        <DeleteIcon className="delete-icon" fill="red" onClick={() => this.deleteNote(note._id)} />
                        <TransIcon className="trans-icon" fill="red" onClick={() => this.translateNote(note)} />
                    </span>
                </li>)}
            </ul>
            <div className="btn-groups">
                <button onClick={() => this.addNote("Click to edit")}>+</button>
                <button onClick={this.copyNotes}>Copy</button>
            </div>
        </div>
    }
}

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = { liked: false };
    }

    render() {
        return <div className="container">
            {/* <Header /> */}
            <Menu />
            <Body />
            {/* <Footer /> */}
        </div>
    }
}

let domContainer = document.querySelector('#root');
ReactDOM.render(<App />, domContainer);